import structfrom enum import Enumimport argparsefrom os import getenvimport socketimport randomclass client:    # ******************** TYPES *********************    # *    # * @brief Return codes for the protocol methods    class RC(Enum):        OK = 0        ERROR = 1        USER_ERROR = 2    # ****************** ATTRIBUTES ******************    _server = None    _port = -1    # ******************** METHODS *******************    @staticmethod    def recv_until_null(sock):        buffer = bytearray()        while True:            byte = sock.recv(1)            if not byte:                # El socket se cerró antes de recibir el '\0'                break            if byte == b'\0':                break            buffer.extend(byte)        return buffer.decode('utf-8')    #Como hay funciones como register, unregister, disconnect, list_users, list_content    #solo envian operacion y user, se extrae el método para calidad de codigo    @staticmethod    def send_op_and_user(op,user):        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            #Solicitamos conexion al servidor            s.connect((client._server, client._port))            #Enviamos register y el usuario seguido de \0            s.sendall(op.encode('utf-8') + b'\0')            s.sendall(user.encode('utf-8') + b'\0')            rcv = s.recv(1)            rcv = (rcv.decode('utf-8'))            if len(rcv) < 1:                return client.RC.ERROR            if int(rcv) == 0:                return client.RC.OK            if int(rcv) == 1:                return client.RC.USER_ERROR            else:                return client.RC.ERROR    @staticmethod    def register(user):        return client.send_op_and_user('REGISTER', user)    @staticmethod    def unregister(user):        return client.send_op_and_user('UNREGISTER', user)    @staticmethod    def connect(user):        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            #Solicitamos conexion al servidor            op = "CONNECT"            #ESTO HAY QUE CAMBIARALO A QUE EL SISTEMA BUSQUE UN PUERTO LIBRE, LO ASIGNE, Y EL RESTO            # DEL METODO SE TRATE DESDE UN HILO            s.connect((client._server, client._port))            #Enviamos register y el usuario seguido de \0            s.sendall(op.encode('utf-8') + b'\0')            s.sendall(user.encode('utf-8') + b'\0')            p = random.randint(1200,5000)            port = str(p)            s.sendall(port.encode('utf-8') + b'\0')            rcv = s.recv(1)            rcv = (rcv.decode('utf-8'))            if len(rcv) < 1:                return client.RC.ERROR            if int(rcv) == 0:                return client.RC.OK            if int(rcv) == 1:                return client.RC.USER_ERROR            else:                return client.RC.ERROR    @staticmethod    def disconnect(user):        return client.send_op_and_user('DISCONNECT', user)    @staticmethod    def publish(fileName, description):        #  Write your code here        print(fileName)        print(description)        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            s.connect((client._server, client._port))            s.sendall(b'PUBLISH\0')            s.sendall(fileName.encode('utf-8') + b'\0')            s.sendall(description.encode('utf-8') + b'\0')        return client.RC.ERROR    @staticmethod    def delete(fileName, user):  # AQUI USER NO SALIA, PERO EN EL ENUNCIADO SALE QUE SE TIENE QUE ENVIAR        #  Write your code here        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            #Solicitamos conexion al servidor            s.connect((client._server, client._port))            #Enviamos delete y el usuario seguido de \0            s.sendall(b'DELETE\0')            s.sendall(user.encode('utf-8') + b'\0')            s.sendall(fileName.encode('utf-8') + b'\0')        return client.RC.ERROR    @staticmethod    def listusers(user):   #LA DUDA DEL CORREO, he puesto user pero no deberia        #  Write your code here        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            #Solicitamos conexion al servidor            op = "LIST_USERS"            #ESTO HAY QUE CAMBIARALO A QUE EL SISTEMA BUSQUE UN PUERTO LIBRE, LO ASIGNE, Y EL RESTO            # DEL METODO SE TRATE DESDE UN HILO            s.connect((client._server, client._port))            #Enviamos register y el usuario seguido de \0            s.sendall(op.encode('utf-8') + b'\0')            s.sendall(user.encode('utf-8') + b'\0')            rcv = client.recv_until_null(s)            if len(rcv) < 1:                return client.RC.ERROR            if int(rcv) == 0:                rcv = client.recv_until_null(s)                print(rcv)                for i in range(int(rcv)):                    recall_user = client.recv_until_null(s)                    recall_ip = client.recv_until_null(s)                    recall_port = client.recv_until_null(s)                    print(f"{recall_user} {recall_ip} {recall_port}")            if int(rcv) == 1:                return client.RC.USER_ERROR            else:                return client.RC.ERROR    @staticmethod    def listcontent(user):        #  Write your code here        return client.RC.ERROR    @staticmethod    def getfile(user, remote_FileName, local_FileName):        #  Write your code here        return client.RC.ERROR    # *    # **    # * @brief Command interpreter for the client. It calls the protocol functions.    @staticmethod    def shell():        while (True):            try:                command = input("c> ")                line = command.split(" ")                if len(line) > 0:                    line[0] = line[0].upper()                    if line[0] == "REGISTER":                        if len(line) == 2:                            answer = client.register(line[1])                            if answer == client.RC.OK:                                print("REGISTER OK")                            elif answer == client.RC.USER_ERROR:                                print("USERNAME IN USE")                        else:                            print("Syntax error. Usage: REGISTER <userName>")                    elif line[0] == "UNREGISTER":                        if len(line) == 2:                            answer = client.unregister(line[1])                            if answer == client.RC.OK:                                print("UNREGISTER OK")                            elif answer == client.RC.USER_ERROR:                                print("USER DOES NOT EXIST")                            else:                                print("UNREGISTER FAIL")                        else:                            print("Syntax error. Usage: UNREGISTER <userName>")                    elif line[0] == "CONNECT":                        if len(line) == 2:                            client.connect(line[1])                        else:                            print("Syntax error. Usage: CONNECT <userName>")                    elif line[0] == "PUBLISH":                        if len(line) >= 3:                            #  Remove first two words                            description = ' '.join(line[2:])                            client.publish(line[1], description)                        else:                            print("Syntax error. Usage: PUBLISH <fileName> <description>")                    elif line[0] == "DELETE":                        if len(line) == 3:                            client.delete(line[1], line[2])                        else:                            print("Syntax error. Usage: DELETE <fileName> <userName>")                    #DELETE original                    #elif line[0] == "DELETE":                    #    if len(line) == 2:                    #        client.delete(line[1])                    #    else:                    #        print("Syntax error. Usage: DELETE <fileName>")                    #elif line[0] == "LIST_USERS":                    #    if len(line) == 1:                    #        client.listusers()                    #    else:                    #        print("Syntax error. Use: LIST_USERS")                    elif line[0] == "LIST_USERS":                        if len(line) == 2:                            client.listusers(line[1])                        else:                            print("Syntax error. Use: LIST_USERS")                    elif line[0] == "LIST_CONTENT":                        if len(line) == 2:                            client.listcontent(line[1])                        else:                            print("Syntax error. Usage: LIST_CONTENT <userName>")                    elif line[0] == "DISCONNECT":                        if len(line) == 2:                            client.disconnect(line[1])                        else:                            print("Syntax error. Usage: DISCONNECT <userName>")                    elif line[0] == "GET_FILE":                        if len(line) == 4:                            client.getfile(line[1], line[2], line[3])                        else:                            print("Syntax error. Usage: GET_FILE <userName> <remote_fileName> <local_fileName>")                    elif line[0] == "QUIT":                        if len(line) == 1:                            break                        else:                            print("Syntax error. Use: QUIT")                    else:                        print("Error: command " + line[0] + " not valid.")            except Exception as e:                print("Exception: " + str(e))    # *    # * @brief Prints program usage    @staticmethod    def usage():        print("Usage: python3 client.py -s <server> -p <port>")    # *    # * @brief Parses program execution arguments    @staticmethod    def parseArguments(argv):        parser = argparse.ArgumentParser()        parser.add_argument('-s', type=str, required=True, help='Server IP')        parser.add_argument('-p', type=int, required=True, help='Server Port')        args = parser.parse_args()        if args.s is None:            parser.error("Usage: python3 client.py -s <server> -p <port>")            return False        if (args.p < 1024) or (args.p > 65535):            parser.error("Error: Port must be in the range 1024 <= port <= 65535")            return False        client._server = args.s        client._port = args.p        return True    # ******************** MAIN *********************    @staticmethod    def main(argv):        if not client.parseArguments(argv):            client.usage()            return        #  Write code here        client.shell()        print("+++ FINISHED +++")if __name__ == "__main__":    client.main([])