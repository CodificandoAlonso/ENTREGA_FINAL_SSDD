import os, threading, argparse, socket, re, io, sysfrom enum import Enumfrom contextlib import redirect_stdoutfrom zeep import Clientclass client:    # ******************** TYPES *********************    # *    # * @brief Return codes for the protocol methods    class RC(Enum):        # This will be divided into the methods implemented below, each of them will have        # all his cases covered. OK case is common to every method        OK = 0        # ******************** REGISTER **********************        REG_USE_ERR = 1  # register username in USE        REG_ERR = 2  # register error        # ******************** UNREGISTER ********************        UNR_DNE_ERR = 1  # unregister username Does Not Exist(DNE)        UNR_ERR = 2  # unregister error        # ******************** CONNECT ***********************        CNT_DNE_ERR = 1  # connect username Does Not Exist        CNT_USE_ERR = 2  # connect username connected        CNT_ERR = 3  # connect error        # ******************** PUBLISH ************************        PBH_DNE_ERR = 1  # publish username Does Not Exist(DNE)        PBH_CNX_ERR = 2  # publish username is not connected        PBH_FAP_ERR = 3  # publish File Already Published(FAP)        PBH_ERR = 4  # publish error        # ******************** DELETE *************************        DTE_DNE_ERR = 1  # delete username Does Not Exist(DNE)        DTE_CNX_ERR = 2  # delete username is not connected        DTE_FNP_ERR = 3  # delete File Not Published(FNP)        DTE_ERR = 4  # delete error        # ******************** LIST_USERS *********************        LU_DNE_ERR = 1  # List_users username Does Not Exist(DNE)        LU_CNX_ERR = 2  # List_users username is not connected        LU_ERR = 3  # list_users error        # ******************** LIST_CONTENT *******************        LC_DNE_ERR = 1  # List_content username Does Not Exist(DNE)        LC_CNX_ERR = 2  # List_content username is not connected        LC_UDNE_ERR = 3  # List_content user_content does not exist        LC_ERR = 4  # List_content error        # ******************** DISCONNECT *********************        DC_DNE_ERR = 1  # Disconnect username Does Not Exist(DNE)        DC_CNX_ERR = 2  # Disconnect username is not connected        DC_ERR = 3  # Disconnect error        # ******************** GET_FILE *********************        GF_FNE_ERR = 1  # Get_File File Not Exist(FNE)        GF_ERR = 2  # Get_File error    # ****************** ATTRIBUTES ******************    _webservice = None    _clnt_service = None    _ws_port = 8000    _server = None    _port = -1    _user = None    _thread = None    _stop_event = threading.Event()    # ******************** METHODS *******************    # * @brief Method to initializise the web server to invocate the get_time service provided by the server    # * It uses the client server and client port provided by the user via command line    @staticmethod    def init_ws_client():        client._webservice = f'http://localhost:{client._ws_port}/?wsdl'        client._clnt_service = Client(wsdl=client._webservice)    # * @brief Method to receive bytes of information until verifying a \0 byte(byte that in c(server language)    # * specifies the end of an array or a group of data.    @staticmethod    def recv_until_null(sock):        buffer = bytearray()        while True:            byte = sock.recv(1)            if not byte:                # Socket close before \0                break            if byte == b'\0':                break            buffer.extend(byte)        raw = bytes(buffer)        s = raw.decode('utf-8')        if re.fullmatch(r'-?\d+', s):            return raw        return s    # * @brief Method to redirect an output from an specific function. This is used to call list_users but not    # * to print the output, but redirect that into a local variable.    @staticmethod    def redirect_output(func, *args, **kwargs) -> list:        buf = io.StringIO()        with redirect_stdout(buf):            func(*args, **kwargs)        texto = buf.getvalue()        lineas = texto.splitlines()        return list(lineas)    @staticmethod    def format_list_into_dict(input_list):        input_list = input_list[1:]        output_dict = {}        for elem in input_list:            aux = elem.split(" ")            # ignore tab(4 spaces) that is defaulted storaged in the string callback, so starting point will be 4            output_dict[aux[4]] = {"ip": aux[5], "port": int(aux[6])}        return output_dict    # * @brief Method to send the operation array and the username to the server. Standard to every server-connexion    # related method implemented.    @staticmethod    def send_op_and_user(method_socket, op, user):        # Request connect        method_socket.connect((client._server, client._port))        # Send OP        method_socket.sendall(op.encode('utf-8') + b'\0')        current = list(client._clnt_service.service.get_time().split(' '))        str = f"{current[1]} {current[0]}"        # SEND datetime granted by webservice        method_socket.sendall(str.encode('utf-8') + b'\0')        # Send user        method_socket.sendall(user.encode('utf-8') + b'\0')    # * @brief Method implemented to stablish conectivity between clients. this is part of the P2P part between those    # clients who want to exchange files    @staticmethod    def stablish_connection_clients(origin_socket, ip, port, path):        origin_socket.connect((ip, port))        op = "GET_FILE"        origin_socket.sendall(op.encode('utf-8') + b'\0')        origin_socket.sendall(path.encode('utf-8') + b'\0')    # * @brief Method to verify the outcome of the receiving answer byte from the server.    # * Tedious and long but necessary to have a clean code.    @staticmethod    def rcv_info_byte(op, byte):        if op == "REGISTER":            if len(byte) < 1:                print("c> REGISTER FAIL")                return client.RC.REG_ERR            if int(byte[0]) == 0:                print("c> REGISTER OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> USERNAME IN USE")                return client.RC.REG_USE_ERR            else:                print("c> REGISTER FAIL")                return client.RC.REG_ERR        if op == "UNREGISTER":            if len(byte) < 1:                print("c> UNREGISTER FAIL")                return client.RC.UNR_ERR            if int(byte[0]) == 0:                print("c> UNREGISTER OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> USER DOES NOT EXIST")                return client.RC.UNR_DNE_ERR            else:                print("c> UNREGISTER FAIL")                return client.RC.UNR_ERR        if op == "CONNECT":            if len(byte) < 1:                print("c> CONNECT FAIL")            if int(byte[0]) == 0:                print("c> CONNECT OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> CONNECT FAIL, USER DOES NOT EXIST")                return client.RC.CNT_DNE_ERR            if int(byte[0]) == 2:                print("c> USER ALREADY CONNECTED")                return client.RC.CNT_USE_ERR            else:                print("c> CONNECT FAIL")                return client.RC.CNT_ERR        if op == "PUBLISH":            if len(byte) < 1:                print("c> PUBLISH FAIL")                return client.RC.PBH_ERR            if int(byte[0]) == 0:                print("c> PUBLISH OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> PUBLISH FAIL, USER DOES NOT EXIST")                return client.RC.PBH_DNE_ERR            if int(byte[0]) == 2:                print("c> PUBLISH FAIL, USER NOT CONNECTED")                return client.RC.PBH_CNX_ERR            if int(byte[0]) == 3:                print("c> PUBLISH FAIL, CONTENT ALREADY PUBLISHED")                return client.RC.PBH_FAP_ERR            else:                print("c> PUBLISH FAIL")                return client.RC.PBH_ERR        if op == "DELETE":            if len(byte) < 1:                print("c> DELETE FAIL")                return client.RC.DTE_ERR            if int(byte[0]) == 0:                print("c> DELETE OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> DELETE FAIL, USER DOES NOT EXIST")                return client.RC.DTE_DNE_ERR            if int(byte[0]) == 2:                print("c> DELETE FAIL, USER NOT CONNECTED")                return client.RC.DTE_CNX_ERR            if int(byte[0]) == 3:                print("c> DELETE FAIL, CONTENT NOT PUBLISHED")                return client.RC.DTE_FNP_ERR            else:                print("c> DELETE FAIL")                return client.RC.DTE_ERR        if op == "LIST_USERS":            if len(byte) < 1:                print("c> LIST_USERS FAIL")                return client.RC.LU_ERR            if int(byte[0]) == 0:                print("c> LIST_USERS OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> LIST_USERS FAIL, USER DOES NOT EXIST")                return client.RC.LU_DNE_ERR            if int(byte[0]) == 2:                print("c> LIST_USERS FAIL, USER NOT CONNECTED")                return client.RC.LU_CNX_ERR            else:                print("c> LIST_USERS FAIL")                return client.RC.LU_ERR        if op == "LIST_CONTENT":            if len(byte) < 1:                print("c> LIST_CONTENT FAIL")                return client.RC.LC_ERR            if int(byte[0]) == 0:                print("c> LIST_CONTENT OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> LIST_CONTENT FAIL, USER DOES NOT EXIST")                return client.RC.LC_DNE_ERR            if int(byte[0]) == 2:                print("c> LIST_CONTENT FAIL, USER NOT CONNECTED")                return client.RC.LC_CNX_ERR            if int(byte[0]) == 3:                print("c> LIST_CONTENT FAIL, REMOTE USER DOES NOT EXIST")                return client.RC.LC_UDNE_ERR            else:                print("c> LIST_CONTENT FAIL")                return client.RC.LC_ERR        if op == "DISCONNECT":            if len(byte) < 1:                print("c> DISCONNECT FAIL")                return client.RC.DC_ERR            if int(byte[0]) == 0:                print("c> DISCONNECT OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> DISCONNECT FAIL, USER DOES NOT EXIST")                return client.RC.DC_DNE_ERR            if int(byte[0]) == 2:                print("c> DISCONNECT FAIL, USER NOT CONNECTED")                return client.RC.DC_CNX_ERR            else:                print("c> DISCONNECT FAIL")                return client.RC.DC_ERR        if op == "GET_FILE":            if len(byte) < 1:                print("c> GET_FILE FAIL")                return client.RC.GF_ERR            if int(byte[0]) == 0:                print("c> GET_FILE OK")                return client.RC.OK            if int(byte[0]) == 1:                print("c> GET_FILE FAIL, FILE NOT EXIST")                return client.RC.GF_FNE_ERR            else:                print("c> GET_FILE FAIL")                return client.RC.GF_ERR    # * @brief Method to find and return an avaliable port  in the system    @staticmethod    def search_free_port():        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            s.bind(('0.0.0.0', 0))            free_port = s.getsockname()[1]        return free_port    # * @brief Method which is the function for the client's thread service. This will act as a server, hearing    # the incoming requests and, i9f the body of the request is complete, it sends the file content.    @staticmethod    def hear_petitions(puerto):        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as servidor:            servidor.bind(('0.0.0.0', puerto))            servidor.listen()            servidor.settimeout(0.1)            # Timeout for handling the stopping event correctly            while not client._stop_event.is_set():                try:                    cliente, addr = servidor.accept()                except socket.timeout:                    continue                # Recieving OP-code and fileroute                operation = client.recv_until_null(cliente)                file_route = client.recv_until_null(cliente)                if operation != "GET_FILE":                    answer = bytes([2])                    cliente.sendall(answer)                    cliente.close()                try:                    with open(file_route, "rb") as file:                        r = file.read()                        len_answer = str(len(r))                        answer = bytes([0])                        cliente.sendall(answer)                        cliente.sendall(len_answer.encode('utf-8') + b'\0')                        cliente.sendall(r)                except FileNotFoundError:                    answer = bytes([1])                    cliente.sendall(answer)                    cliente.close()                cliente.close()    @staticmethod    def stop_thread():        # Set event and close thread        client._stop_event.set()        if client._thread is not None:            client._thread.join()        client._user = None    @staticmethod    def register(user):        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            client.send_op_and_user(s, "REGISTER", user)            rcv = s.recv(1)            return client.rcv_info_byte("REGISTER", rcv)    @staticmethod    def unregister(user):        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            client.send_op_and_user(s, "UNREGISTER", user)            rcv = s.recv(1)            if client.rcv_info_byte("UNREGISTER", rcv) == client.RC.OK:                if client._user == user:                    client.stop_thread()    @staticmethod    def connect(user):        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            # If the process already have a client connected, it gets disconnected before connecting the new one            if client._user is not None:                client.disconnect(client._user)                client.stop_thread()            client.send_op_and_user(s, "CONNECT", user)            port = client.search_free_port()            port_send = str(port)            s.sendall(port_send.encode('utf-8') + b'\0')            rcv = s.recv(1)            if client.rcv_info_byte("CONNECT", rcv) == client.RC.OK:                client._user = user                client._thread = threading.Thread(target=client.hear_petitions, args=(port,))                client._thread.daemon = True                client._thread.start()    @staticmethod    def disconnect(user):        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            if client._user is None:                print("c> DISCONNECT FAIL, USER NOT CONNECTED")                return client.RC.DC_CNX_ERR            if client._user != user:                print("c> DISCONNECT FAIL, YOU CANNOT DISCONNECT THIS USER:", user)                return client.RC.DC_ERR            client.send_op_and_user(s, "DISCONNECT", user)            if client.rcv_info_byte("DISCONNECT", s.recv(1)) == client.RC.OK:                client.stop_thread()    @staticmethod    def publish(fileName, description):        if client._user is None:            print("c> PUBLISH FAIL, USER NOT CONNECTED")            return client.RC.PBH_CNX_ERR        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            # publish file if the client is not owner of the file in its filesystem            if not os.path.exists(fileName):                print("c> PUBLISH FAIL")                return client.RC.PBH_ERR            if fileName.startswith("."):                fileName = os.path.abspath(fileName)            client.send_op_and_user(s, "PUBLISH", client._user)            s.sendall(fileName.encode('utf-8') + b'\0')            s.sendall(description.encode('utf-8') + b'\0')            rcv = s.recv(1)            return client.rcv_info_byte("PUBLISH", rcv)    @staticmethod    def delete(fileName):        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            if client._user is None:                print("c> DELETE FAIL, USER NOT CONNECTED")                return client.RC.DTE_CNX_ERR            if fileName.startswith("."):                fileName = os.path.abspath(fileName)            client.send_op_and_user(s, "DELETE", client._user)            s.sendall(fileName.encode('utf-8') + b'\0')            return client.rcv_info_byte("DELETE", s.recv(1))    @staticmethod    def listusers():        if client._user is None:            print("c> LIST_USERS FAIL, USER NOT CONNECTED")            return client.RC.LU_CNX_ERR        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            if client._user is None:                print("c> LIST USERS FAIL, USER NOT CONNECTED")                return client.RC.LU_CNX_ERR            client.send_op_and_user(s, "LIST_USERS", client._user)            if (client.rcv_info_byte("LIST_USERS", s.recv(1))) == client.RC.OK:                rcv = client.recv_until_null(s)                for i in range(int(rcv)):                    recall_user = client.recv_until_null(s)                    recall_ip = client.recv_until_null(s)                    recall_port = client.recv_until_null(s)                    print(f"    {recall_user} {recall_ip} {int(recall_port)}")    @staticmethod    def listcontent(user):        if client._user is None:            print("c> LIST_CONTENT FAIL, USER NOT CONNECTED")            return client.RC.LC_CNX_ERR        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            client.send_op_and_user(s, "LIST_CONTENT", client._user)            s.sendall(user.encode('utf-8') + b'\0')            if (client.rcv_info_byte("LIST_CONTENT", s.recv(1))) == client.RC.OK:                rcv = client.recv_until_null(s)                for i in range(int(rcv)):                    print(f"{client.recv_until_null(s)}")    @staticmethod    def getfile(user, remote_FileName, local_FileName):        if client._user is None:            print("c> GETFILE FAIL, USER NOT CONNECTED")            return client.RC.GF_ERR        # Redirect the output from list_users to a variable        callback = client.redirect_output(client.listusers)        if len(callback) < 2:  # If you receive 1 line, only LIST_USERS OK, nobody more than you is connected, ergo            # the client you are trying to request a file is not connected            print("c> GETFILE FAIL, REMOTE USER NOT CONNECTED")            return client.RC.GF_ERR        # transform into a dict        connected_dict = client.format_list_into_dict(callback)        # If theuser requested is not in dict        if user not in connected_dict.keys():            print("c> GETFILE FAIL, REMOTE USER NOT CONNECTED")            return client.RC.GF_ERR        # Extract ip and port        ip, port = connected_dict[user].values()        # Stablish conection and receive the file        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:            client.stablish_connection_clients(s, ip, port, remote_FileName)            rcv = s.recv(1)            if client.rcv_info_byte("GET_FILE", rcv) == client.RC.OK:                rcv = client.recv_until_null(s)                max_len = int(rcv)                buffer = 0                with open(local_FileName, "wb") as file:                    while True:                        data = s.recv(max_len)                        buffer += len(data)                        file.write(data)                        if not data or buffer == max_len:                            break                return client.RC.OK            else:                return client.RC.GF_FNE_ERR    # *    # **    # * @brief Command interpreter for the client. It calls the protocol functions.    @staticmethod    def shell():        while True:            try:                command = input("c> ")                line = command.split(" ")                if len(line) > 0:                    line[0] = line[0].upper()                    if line[0] == "REGISTER":                        if len(line) == 2:                            client.register(line[1])                        else:                            print("Syntax error. Usage: REGISTER <userName>")                    elif line[0] == "UNREGISTER":                        if len(line) == 2:                            client.unregister(line[1])                        else:                            print("Syntax error. Usage: UNREGISTER <userName>")                    elif line[0] == "CONNECT":                        if len(line) == 2:                            client.connect(line[1])                        else:                            print("Syntax error. Usage: CONNECT <userName>")                    elif line[0] == "PUBLISH":                        if len(line) >= 3:                            #  Remove first two words                            description = ' '.join(line[2:])                            client.publish(line[1], description)                        else:                            print("Syntax error. Usage: PUBLISH <fileName> <description>")                    elif line[0] == "DELETE":                        if len(line) == 2:                            client.delete(line[1])                        else:                            print("Syntax error. Usage: DELETE <fileName>")                    elif line[0] == "LIST_USERS":                        if len(line) == 1:                            client.listusers()                        else:                            print("Syntax error. Use: LIST_USERS")                    elif line[0] == "LIST_CONTENT":                        if len(line) == 2:                            client.listcontent(line[1])                        else:                            print("Syntax error. Usage: LIST_CONTENT <userName>")                    elif line[0] == "DISCONNECT":                        if len(line) == 2:                            client.disconnect(line[1])                        else:                            print("Syntax error. Usage: DISCONNECT <userName>")                    elif line[0] == "GET_FILE":                        if len(line) == 4:                            client.getfile(line[1], line[2], line[3])                        else:                            print("Syntax error. Usage: GET_FILE <userName> <remote_fileName> <local_fileName>")                    elif line[0] == "QUIT":                        if len(line) == 1:                            if client._user is not None:                                client.disconnect(client._user)                            break                        else:                            print("Syntax error. Use: QUIT")                    else:                        print("Error: command " + line[0] + " not valid.")            except Exception as e:                print("Exception: " + str(e))        # *        # * @brief Prints program usage    @staticmethod    def usage():        print("Usage: python3 client.py -s <server> -p <port> [-ws <ws-port>]")    # *    # * @brief Parses program execution arguments    @staticmethod    def parseArguments(argv):        parser = argparse.ArgumentParser()        parser.add_argument('-s', type=str, required=True, help='Server IP')        parser.add_argument('-p', type=int, required=True, help='Server Port')        parser.add_argument('-ws', '--ws-port', type=int, default=4567, help='Web service (SOAP) Port')        args = parser.parse_args()        if args.s is None:            parser.error("Usage: python3 client.py -s <server> -p <port>")            return False        if (args.p < 1024) or (args.p > 65535):            parser.error("Error: Port must be in the range 1024 <= port <= 65535")            return False        if not (1 <= args.ws_port <= 65535):            parser.error("Error: Web service port must be in the range 1 <= ws-port <= 65535")            return False        client._server = args.s        client._port = args.p        client._ws_port = args.ws_port        client.init_ws_client()        return True    # ******************** MAIN *********************    @staticmethod    def main(argv):        if not client.parseArguments(argv):            client.usage()            return        client.shell()        print("+++ FINISHED +++")if __name__ == "__main__":    #client.main([])    client.main(sys.argv[1:])